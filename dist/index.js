export { c as CID_ALGORITHM, a as CID_ALGORITHM_CODES, b as CID_ALGORITHM_NAMES } from './chunk-VGBIRFOR.js';
import { Piscina } from 'piscina';
import { promises, createReadStream } from 'fs';
import { parse as parse$1 } from 'csv-parse';
import { parse } from 'csv-parse/sync';
import { stringify } from 'csv-stringify/sync';
import { access, constants, stat } from 'fs/promises';
import I from 'path';
import { clearInterval } from 'node:timers';

var h=import.meta.dirname;h=h.replace("src","dist");h=h+"/worker.js";var f=new URL(h).href;console.log("Worker URL: ",f);var c=class{piscina;constructor(e){this.piscina=new Piscina({maxThreads:4,filename:e||process.env.WORKER_URL||f});}async computeCIDs(e,t){return this.piscina.run({filePath:e,algorithms:t})}};var m=class{constructor(e,t){this.targetHash=e;this.fileIDComputer=new c(t);}fileIDComputer;async computeMissingHash(e,t){let i=this.targetHash.filter(r=>!t[r]);if(i.length===0)return;(await this.fileIDComputer.computeCIDs(e,i)).forEach((r,a)=>{let n=i[a];t[n]=r;});}};async function l(o){try{return await access(o,constants.F_OK),!0}catch{return !1}}var q=["path","size","mtime"],p=class{constructor(e,t=["cid_sha1","cid_sha2-256"]){this.filePath=e;this.targetHash=t;if(!e)throw new Error("Invalid index file path")}cache=new Map;intervalId;intervalTime=3e4;lastIndexFileSize=0;lastCacheFile;indexOpsInProgress=!1;hasChanged=!1;initialLoad;getCache(){return new Map(this.cache)}async init(e=!0){return this.initialLoad||(this.initialLoad=new Promise(async(t,i)=>{try{if(!this.checkCSVHeaders(this.filePath))throw new Error("Invalid index file headers");await this.loadIndex(),e&&this.start(),t();}catch(s){i(s);}})),this.initialLoad}checkCSVHeaders(e){let t=parse(e,{bom:!0,columns:!0,skip_empty_lines:!0});if(t.length===0)return !0;let i=Object.keys(t[0]);return ["path","size","mtime",...this.targetHash].every(r=>i.includes(r))}start(){this.startAutoSave(this.intervalTime);}stopAutoSave(){this.intervalId&&clearInterval(this.intervalId);}startAutoSave(e){this.stopAutoSave(),this.intervalTime=e,this.intervalId=setInterval(()=>this.saveCacheToFile(),e);}async loadIndex(){if(await l(this.filePath)){let e=await promises.stat(this.filePath);if(this.lastIndexFileSize!==e.size){let t=await this.readCsv();for(let i of t)this.cache.set(i.path,i);return this.lastIndexFileSize=e.size,this.lastCacheFile=t,t}else return this.lastCacheFile}return []}loadIndexFromCache(){return Array.from(this.cache.values())}async readCsv(){if(!await l(this.filePath))return [];let e=performance.now(),t=parse$1({columns:!0,skip_empty_lines:!0}),i=[];return new Promise((s,r)=>{createReadStream(this.filePath).pipe(t).on("data",a=>{i.push(a);}).on("end",()=>{s(i),console.log(`Index read time ${performance.now()-e}ms`);}).on("error",a=>{r(a);});})}async saveCacheToFile(){if(this.indexOpsInProgress||!this.hasChanged)return;this.hasChanged=!1,this.indexOpsInProgress=!0;let e=performance.now(),t=await this.loadIndex();if(this.cache.size!==0){let r=this.loadIndexFromCache().filter(a=>!t.find(n=>n.path===a.path));if(r.length!==0){let a=stringify(r,{header:t.length===0,columns:[{key:"path",header:"path"},{key:"size",header:"size"},{key:"mtime",header:"mtime"},...this.targetHash.map(n=>({key:n,header:n}))]});await promises.appendFile(this.filePath,a);}}let i=performance.now()-e;console.log(`Index saved in ${i}ms`),i*10>this.intervalTime&&(this.startAutoSave(i*10),console.log(`Index save interval increased to ${i*10}ms`)),this.indexOpsInProgress=!1;}getCidForFile(e,t,i){let s=I.basename(e),r=this.cache.get(s);if(r){if(r.mtime){if(r.size===t+""&&r.mtime===i)return r}else if(r.size===t+"")return r}return null}addFileCid(e,t,i,s){if(!e||!t||!i||!s)throw new Error("Invalid parameters");let r=t+"",a=I.basename(e),n={path:a,size:r,mtime:i,...s};this.cache.set(a,n),this.hasChanged=!0;}};var g=class{constructor(e,t=["cid_sha1","cid_sha2-256"],i){this.targetHash=t;this.hashComputer=new m(this.targetHash,i),this.hashIndexManager=new p(e);}hashIndexManager;hashComputer;async computeMissingHash(e,t){await this.hashIndexManager.init();let i=await stat(e);if(this.hashIndexManager.getCache().has(I.basename(e))){let s=this.hashIndexManager.getCidForFile(e,i.size,i.mtime.toISOString());if(s)for(let r of this.targetHash)!t[r]&&s[r]&&(t[r]=s[r]);}await this.hashComputer.computeMissingHash(e,t),this.hashIndexManager.addFileCid(e,i.size,i.mtime.toISOString(),t);}};

export { g as ComputeHashIndexCache, c as FileIDComputer, m as HashComputer, p as HashIndexManager, q as INDEX_HEADERS, l as existsAsync };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map