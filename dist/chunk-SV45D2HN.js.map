{"version":3,"sources":["../src/lib/file-id/ComputeHash.ts","../src/lib/file-id/CreateHasher.ts","../src/lib/file-id/Crc32Hash.ts"],"names":[],"mappings":";;;;;AACA,SAAQ,gBAAe;AACvB,SAAQ,cAAa;AACrB,SAAQ,WAAU;;;ACDlB,SAAQ,kBAAiB;;;ACFzB,OAAO,WAAW;AAGX,IAAM,YAAN,MAAsC;AAAA,EACjC,OAAe;AAAA,EAEvB,OAAO,MAA0B;AAE7B,SAAK,OAAO,MAAM,IAAI,MAAM,KAAK,IAAI;AACrC,WAAO;AAAA,EACX;AAAA,EAEA,SAAiB;AACb,UAAM,SAAS,OAAO,MAAM,CAAC;AAC7B,WAAO,aAAa,KAAK,MAAM,CAAC;AAChC,WAAO;AAAA,EACX;AACJ;;;ADZO,IAAM,YAAY;AAAA,EACrB,wBAA0B;AAAA,EAC1B,oBAAwB;AAAA,EACxB,sBAAyB;AAAA,EACzB,4BAA2B;AAAA,EAC3B,8BAA6B;AAAA,EAC7B,8BAA6B;AACjC;AAOA,eAAsB,aAAa,MAAgD;AAC/E,UAAQ,MAAM;AAAA,IACV;AACI,aAAO,WAAW,QAAQ;AAAA,IAC9B;AACI,aAAO,WAAW,MAAM;AAAA,IAC5B;AACI,aAAO,WAAW,KAAK;AAAA,IAC3B;AACI,aAAO,WAAW,UAAU;AAAA,IAChC;AACI,aAAO,WAAW,UAAU;AAAA,IAChC;AACI,aAAO,IAAI,UAAU;AAAA,IACzB;AACI,YAAM,IAAI,MAAM,0BAA0B,IAAI,EAAE;AAAA,EACxD;AACJ;;;ADvBA,eAAsB,YAAY,EAAC,QAAQ,WAAU,GAG/B;AAClB,QAAM,UAAU,MAAM,cAAc,UAAU;AAG9C,MAAI,kBAAkB,UAAU;AAE5B,qBAAiB,SAAS,QAAQ;AAC9B,iBAAW,QAAQ,SAAS;AACxB,cAAM,KAAK,OAAO,OAAO,KAAe;AAAA,MAC5C;AAAA,IACJ;AAAA,EACJ,OAAO;AAEH,UAAM,SAAS,OAAO,UAAU;AAChC,WAAO,MAAM;AACT,YAAM,EAAC,MAAM,MAAK,IAAI,MAAM,OAAO,KAAK;AACxC,UAAI;AAAM;AAEV,iBAAW,QAAQ,SAAS;AACxB,cAAM,KAAK,OAAO,OAAO,OAAO,KAAK,KAAK,CAAC;AAAA,MAC/C;AAAA,IACJ;AAAA,EACJ;AAEA,SAAO,YAAY,OAAO;AAC9B;AAEA,eAAe,cAAc,YAGxB;AACD,QAAM,UAAU,WAAW,OAAO,UAAQ,OAAO,OAAO,mBAAmB,EAAE,SAAS,IAAI,CAAC,EACtF,IAAI,OAAM,UAAS;AAAA,IAChB,QAAQ,MAAM,aAAa,IAAI;AAAA,IAC/B,MAAM,UAAU,IAAI;AAAA,EACxB,EAAE;AACN,SAAO,MAAM,QAAQ,IAAI,OAAO;AACpC;AAEA,eAAe,YAAY,SAAoE;AAC3F,SAAO,MAAM,QAAQ,IAAI,QAAQ,IAAI,OAAO,EAAC,MAAM,OAAM,MAAM;AAC3D,UAAM,aAAa,MAAM,OAAO,OAAO;AACvC,UAAM,SAAS,OAAO,MAAM,UAAU;AACtC,WAAO,IAAI,SAAS,MAAM,MAAM,EAAE,SAAS;AAAA,EAC/C,CAAC,CAAC;AACN","sourcesContent":["import {CID_ALGORITHM_CODES, CID_ALGORITHM_NAMES} from \"../hash-compute/MultiHashData\";\r\nimport {Readable} from \"stream\";\r\nimport {create} from \"multiformats/hashes/digest\";\r\nimport {CID} from 'multiformats/cid';\r\nimport {createHasher, codeTable} from \"./CreateHasher\";\r\nimport {SimpleHash} from \"./SimpleHash\";\r\n\r\n/**\r\n * Compute the CIDs of a file using specific algorithms\r\n * @param stream The Readable stream of the file\r\n * @param algorithms Array of algorithms ('sha256', 'sha1', etc.)\r\n * @returns Array of CIDs (in the order of the algorithms)\r\n */\r\nexport async function computeCIDs({stream, algorithms}: {\r\n    stream: Readable | ReadableStream;\r\n    algorithms: CID_ALGORITHM_NAMES[]\r\n}): Promise<string[]> {\r\n    const hashers = await hasherDefiner(algorithms);\r\n\r\n    // Check if the environment is Node.js or Browser and handle the stream accordingly\r\n    if (stream instanceof Readable) {\r\n        // Node.js environment\r\n        for await (const chunk of stream) {\r\n            for (const item of hashers) {\r\n                await item.hasher.update(chunk as Buffer);\r\n            }\r\n        }\r\n    } else {\r\n        // Browser environment\r\n        const reader = stream.getReader();\r\n        while (true) {\r\n            const {done, value} = await reader.read();\r\n            if (done) break;\r\n            // Assuming the hasher can handle Uint8Array directly\r\n            for (const item of hashers) {\r\n                await item.hasher.update(Buffer.from(value));\r\n            }\r\n        }\r\n    }\r\n\r\n    return cidFinalize(hashers);\r\n}\r\n\r\nasync function hasherDefiner(algorithms: CID_ALGORITHM_NAMES[]): Promise<{\r\n    hasher: SimpleHash,\r\n    code: CID_ALGORITHM_CODES\r\n}[]> {\r\n    const hashers = algorithms.filter(algo => Object.values(CID_ALGORITHM_NAMES).includes(algo))\r\n        .map(async algo => ({\r\n            hasher: await createHasher(algo),\r\n            code: codeTable[algo]\r\n        }));\r\n    return await Promise.all(hashers);\r\n}\r\n\r\nasync function cidFinalize(hashers: { hasher: SimpleHash, code: number }[]): Promise<string[]> {\r\n    return await Promise.all(hashers.map(async ({code, hasher}) => {\r\n        const hashBuffer = await hasher.digest();\r\n        const digest = create(code, hashBuffer);\r\n        return CID.createV1(code, digest).toString();\r\n    }));\r\n}","import {CID_ALGORITHM_CODES, CID_ALGORITHM_NAMES} from \"../hash-compute/MultiHashData\";\r\nimport {SimpleHash} from \"./SimpleHash\";\r\nimport {createHash} from \"crypto\";\r\nimport {Crc32Hash} from \"./Crc32Hash\";\r\n\r\nexport const codeTable = {\r\n    [CID_ALGORITHM_NAMES.crc32]: CID_ALGORITHM_CODES.crc32,\r\n    [CID_ALGORITHM_NAMES.md5]: CID_ALGORITHM_CODES.md5,\r\n    [CID_ALGORITHM_NAMES.sha1]: CID_ALGORITHM_CODES.sha1,\r\n    [CID_ALGORITHM_NAMES.sha256]: CID_ALGORITHM_CODES.sha256,\r\n    [CID_ALGORITHM_NAMES.sha3_256]: CID_ALGORITHM_CODES.sha3_256,\r\n    [CID_ALGORITHM_NAMES.sha3_384]: CID_ALGORITHM_CODES.sha3_384\r\n}\r\n\r\n/**\r\n * Compute the CIDs of a file using specific algorithms\r\n * @returns Array of CIDs (in the order of the algorithms)\r\n * @param algo\r\n */\r\nexport async function createHasher(algo: CID_ALGORITHM_NAMES): Promise<SimpleHash> {\r\n    switch (algo) {\r\n        case CID_ALGORITHM_NAMES.sha256:\r\n            return createHash(\"sha256\");\r\n        case CID_ALGORITHM_NAMES.sha1:\r\n            return createHash(\"sha1\");\r\n        case CID_ALGORITHM_NAMES.md5:\r\n            return createHash(\"md5\");\r\n        case CID_ALGORITHM_NAMES.sha3_256:\r\n            return createHash(\"sha3-256\");\r\n        case CID_ALGORITHM_NAMES.sha3_384:\r\n            return createHash(\"sha3-384\");\r\n        case CID_ALGORITHM_NAMES.crc32:\r\n            return new Crc32Hash();\r\n        default:\r\n            throw new Error(`Unsupported algorithm: ${algo}`);\r\n    }\r\n}","import crc32 from \"crc-32\";\r\nimport {SimpleHash} from \"@root/file-id/SimpleHash\";\r\n\r\nexport class Crc32Hash implements SimpleHash {\r\n    private _crc: number = undefined;\r\n\r\n    update(data: Buffer): SimpleHash {\r\n        // Update the CRC-32 checksum with the new chunk of data\r\n        this._crc = crc32.buf(data, this._crc);\r\n        return this;\r\n    }\r\n\r\n    digest(): Buffer {\r\n        const buffer = Buffer.alloc(4); // Create a buffer of 4 bytes (32 bits)\r\n        buffer.writeInt32BE(this._crc, 0); // Write the unsigned integer to the buffer in big-endian format\r\n        return buffer;\r\n    }\r\n}"]}