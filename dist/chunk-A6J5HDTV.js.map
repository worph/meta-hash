{"version":3,"sources":["../src/lib/file-id/ComputeHash.ts","../src/lib/file-id/CreateHasher.ts","../src/lib/file-id/Crc32Hash.ts"],"names":["Readable","create","CID","createHash","crc32","Crc32Hash","data","buffer","codeTable","createHasher","algo","computeCIDs","stream","algorithms","hashers","hasherDefiner","chunk","item","reader","done","value","cidFinalize","CID_ALGORITHM_NAMES","code","hasher","hashBuffer","digest"],"mappings":"wCACA,OAAQ,YAAAA,MAAe,SACvB,OAAQ,UAAAC,MAAa,6BACrB,OAAQ,OAAAC,MAAU,mBCClB,OAAQ,cAAAC,MAAiB,SCJzB,OAAOC,MAAW,SAGX,IAAMC,EAAN,KAAsC,CACjC,KAAe,OAEvB,OAAOC,EAAyB,CAE5B,YAAK,KAAOF,EAAM,IAAIE,EAAM,KAAK,IAAI,EAC9B,IACX,CAEA,QAAiB,CACb,IAAMC,EAAS,OAAO,MAAM,CAAC,EAC7B,OAAAA,EAAO,aAAa,KAAK,KAAM,CAAC,EACzBA,CACX,CACJ,EDVO,IAAMC,EAAY,CACpB,cACA,YACA,YACA,kBACA,kBACA,iBACL,EAOO,SAASC,EAAaC,EAAuC,CAChE,OAAQA,EAAM,CACV,mBACI,OAAOP,EAAW,QAAQ,EAC9B,eACI,OAAOA,EAAW,MAAM,EAC5B,cACI,OAAOA,EAAW,KAAK,EAC3B,mBACI,OAAOA,EAAW,UAAU,EAChC,mBACI,OAAOA,EAAW,UAAU,EAChC,gBACI,OAAO,IAAIE,EACf,QACI,MAAM,IAAI,MAAM,0BAA0BK,CAAI,EAAE,CACxD,CACJ,CDzBA,eAAsBC,EAAY,CAAC,OAAAC,EAAQ,WAAAC,CAAU,EAG/B,CAClB,IAAMC,EAAUC,EAAcF,CAAU,EAGxC,GAAID,aAAkBZ,EAElB,cAAiBgB,KAASJ,EACtBE,EAAQ,QAAQG,GAAQA,EAAK,OAAO,OAAOD,CAAe,CAAC,MAE5D,CAEH,IAAME,EAASN,EAAO,UAAU,EAChC,OAAa,CACT,GAAM,CAAC,KAAAO,EAAM,MAAAC,CAAK,EAAI,MAAMF,EAAO,KAAK,EACxC,GAAIC,EAAM,MAEVL,EAAQ,QAAQG,GAAQA,EAAK,OAAO,OAAO,OAAO,KAAKG,CAAK,CAAC,CAAC,CAClE,CACJ,CAEA,OAAOC,EAAYP,CAAO,CAC9B,CAEA,SAASC,EAAcF,EAGnB,CAMA,OALgBA,EAAW,OAAOH,GAAQ,OAAO,OAAOY,CAAmB,EAAE,SAASZ,CAAI,CAAC,EACtF,IAAIA,IAAS,CACV,OAAQD,EAAaC,CAAI,EACzB,KAAMF,EAAUE,CAAI,CACxB,EAAE,CAEV,CAEA,eAAeW,EAAYP,EAAoE,CAC3F,OAAO,MAAM,QAAQ,IAAIA,EAAQ,IAAI,MAAO,CAAC,KAAAS,EAAM,OAAAC,CAAM,IAAM,CAC3D,IAAMC,EAAaD,EAAO,OAAO,EAC3BE,EAASzB,EAAOsB,EAAME,CAAU,EACtC,OAAOvB,EAAI,SAASqB,EAAMG,CAAM,EAAE,SAAS,CAC/C,CAAC,CAAC,CACN","sourcesContent":["import {CID_ALGORITHM_CODES, CID_ALGORITHM_NAMES} from \"../hash-compute/MultiHashData\";\r\nimport {Readable} from \"stream\";\r\nimport {create} from \"multiformats/hashes/digest\";\r\nimport {CID} from 'multiformats/cid';\r\nimport {createHasher, codeTable} from \"./CreateHasher\";\r\nimport {SimpleHash} from \"./SimpleHash\";\r\n\r\n/**\r\n * Compute the CIDs of a file using specific algorithms\r\n * @param stream The Readable stream of the file\r\n * @param algorithms Array of algorithms ('sha256', 'sha1', etc.)\r\n * @returns Array of CIDs (in the order of the algorithms)\r\n */\r\nexport async function computeCIDs({stream, algorithms}: {\r\n    stream: Readable | ReadableStream;\r\n    algorithms: CID_ALGORITHM_NAMES[]\r\n}): Promise<string[]> {\r\n    const hashers = hasherDefiner(algorithms);\r\n\r\n    // Check if the environment is Node.js or Browser and handle the stream accordingly\r\n    if (stream instanceof Readable) {\r\n        // Node.js environment\r\n        for await (const chunk of stream) {\r\n            hashers.forEach(item => item.hasher.update(chunk as Buffer));\r\n        }\r\n    } else {\r\n        // Browser environment\r\n        const reader = stream.getReader();\r\n        while (true) {\r\n            const {done, value} = await reader.read();\r\n            if (done) break;\r\n            // Assuming the hasher can handle Uint8Array directly\r\n            hashers.forEach(item => item.hasher.update(Buffer.from(value)));\r\n        }\r\n    }\r\n\r\n    return cidFinalize(hashers);\r\n}\r\n\r\nfunction hasherDefiner(algorithms: CID_ALGORITHM_NAMES[]): {\r\n    hasher: SimpleHash,\r\n    code: CID_ALGORITHM_CODES\r\n}[] {\r\n    const hashers = algorithms.filter(algo => Object.values(CID_ALGORITHM_NAMES).includes(algo))\r\n        .map(algo => ({\r\n            hasher: createHasher(algo),\r\n            code: codeTable[algo]\r\n        }));\r\n    return hashers;\r\n}\r\n\r\nasync function cidFinalize(hashers: { hasher: SimpleHash, code: number }[]): Promise<string[]> {\r\n    return await Promise.all(hashers.map(async ({code, hasher}) => {\r\n        const hashBuffer = hasher.digest();\r\n        const digest = create(code, hashBuffer);\r\n        return CID.createV1(code, digest).toString();\r\n    }));\r\n}","import {CID_ALGORITHM_CODES, CID_ALGORITHM_NAMES} from \"../hash-compute/MultiHashData\";\r\nimport {Readable} from \"stream\";\r\nimport {ReadableStream} from \"stream/web\";\r\nimport {SimpleHash} from \"./SimpleHash\";\r\nimport {createHash} from \"crypto\";\r\nimport {Crc32Hash} from \"./Crc32Hash\";\r\n\r\nexport const codeTable = {\r\n    [CID_ALGORITHM_NAMES.crc32]: CID_ALGORITHM_CODES.crc32,\r\n    [CID_ALGORITHM_NAMES.md5]: CID_ALGORITHM_CODES.md5,\r\n    [CID_ALGORITHM_NAMES.sha1]: CID_ALGORITHM_CODES.sha1,\r\n    [CID_ALGORITHM_NAMES.sha256]: CID_ALGORITHM_CODES.sha256,\r\n    [CID_ALGORITHM_NAMES.sha3_256]: CID_ALGORITHM_CODES.sha3_256,\r\n    [CID_ALGORITHM_NAMES.sha3_384]: CID_ALGORITHM_CODES.sha3_384\r\n}\r\n\r\n/**\r\n * Compute the CIDs of a file using specific algorithms\r\n * @returns Array of CIDs (in the order of the algorithms)\r\n * @param algo\r\n */\r\nexport function createHasher(algo: CID_ALGORITHM_NAMES): SimpleHash {\r\n    switch (algo) {\r\n        case CID_ALGORITHM_NAMES.sha256:\r\n            return createHash(\"sha256\");\r\n        case CID_ALGORITHM_NAMES.sha1:\r\n            return createHash(\"sha1\");\r\n        case CID_ALGORITHM_NAMES.md5:\r\n            return createHash(\"md5\");\r\n        case CID_ALGORITHM_NAMES.sha3_256:\r\n            return createHash(\"sha3-256\");\r\n        case CID_ALGORITHM_NAMES.sha3_384:\r\n            return createHash(\"sha3-384\");\r\n        case CID_ALGORITHM_NAMES.crc32:\r\n            return new Crc32Hash();\r\n        default:\r\n            throw new Error(`Unsupported algorithm: ${algo}`);\r\n    }\r\n}","import crc32 from \"crc-32\";\r\nimport {SimpleHash} from \"@root/file-id/SimpleHash\";\r\n\r\nexport class Crc32Hash implements SimpleHash {\r\n    private _crc: number = undefined;\r\n\r\n    update(data: Buffer): Crc32Hash {\r\n        // Update the CRC-32 checksum with the new chunk of data\r\n        this._crc = crc32.buf(data, this._crc);\r\n        return this;\r\n    }\r\n\r\n    digest(): Buffer {\r\n        const buffer = Buffer.alloc(4); // Create a buffer of 4 bytes (32 bits)\r\n        buffer.writeInt32BE(this._crc, 0); // Write the unsigned integer to the buffer in big-endian format\r\n        return buffer;\r\n    }\r\n}"]}