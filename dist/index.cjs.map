{"version":3,"sources":["../src/lib/fileID/FileIDComputer.ts","../src/lib/HashComputer.ts","../src/lib/HashIndexManager.ts","../src/lib/ExistsAsync.ts","../src/lib/ComputeHashIndexCache.ts","../src/lib/folder_watcher/FolderWatcher.ts"],"names":["Piscina","distFolder","workerUrl","FileIDComputer","workerPath","filePath","algorithms","HashComputer","targetHash","metadata","neededHashes","hashName","cid","index","hashType","createReadStream","fs","parse","parseSync","stringify","access","constants","existsAsync","path","clearInterval","INDEX_HEADERS","HashIndexManager","hash","autosave","resolve","reject","e","csvContent","records","headers","header","time","stats","record","indexLine","start","parser","err","existingRows","newRows","row","existingRow","csvString","totalTime","fileSize","mtime","fileName","fileNameIndex","hashs","size","baseName","data","stat","ComputeHashIndexCache","indexFilePath","chokidar","readdir","PQueue","FolderWatcher","fileProcessor","WATCH_FOLDER_LIST","config","directory","promises","entries","entry","fullPath","promise","countPromises","acc","current","dirname","folderList","chokidarconfig","watcher","error","folders","i","count"],"mappings":"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","sourcesContent":["import {Piscina} from \"piscina\";\nimport {CID_ALGORITHM_NAMES} from \"../MultiHashData\";\n\n// Construct the URL for the current module\nlet distFolder = import.meta.dirname;\ndistFolder = distFolder.replace('src', 'dist');\ndistFolder = distFolder + \"/worker.js\";\nconst workerUrl = new URL(distFolder).href;\nconsole.log(\"Worker URL: \", workerUrl);\n\nexport class FileIDComputer {\n    private piscina: Piscina;\n\n    constructor(workerPath?:string) {\n        this.piscina = new Piscina({\n            maxThreads: 4,\n            //filename: new URL('./ShaComputeWorker.ts', import.meta.url).href\n            filename: workerPath || process.env.WORKER_URL || workerUrl\n        });\n    }\n\n    /**\n     * Compute the CIDs of a file using specific algorithms\n     * @param filePath The path to the file\n     * @param algorithms Array of algorithms ('sha256', 'sha1')\n     * @returns Array of CIDs (in the order of the algorithms)\n     */\n    public async computeCIDs(filePath: string, algorithms: CID_ALGORITHM_NAMES[]): Promise<string[]> {\n        return this.piscina.run({filePath, algorithms});\n    }\n}\n","import { FileIDComputer } from \"./fileID/FileIDComputer\";\nimport {CID_ALGORITHM_NAMES, ComputeInterface, MultiHashData} from \"./MultiHashData\";\n\nexport class HashComputer implements ComputeInterface{\n    private fileIDComputer:FileIDComputer;\n\n    constructor(private targetHash: CID_ALGORITHM_NAMES[],workerPath?:string) {\n        this.fileIDComputer = new FileIDComputer(workerPath);\n    }\n\n    async computeMissingHash(filePath: string, metadata: MultiHashData): Promise<void> {\n        // Dynamically determine which hashes are needed\n        const neededHashes = this.targetHash.filter(hashName => !metadata[hashName]);\n\n        // If all hashes are already computed, skip the processing\n        if (neededHashes.length === 0) {\n            return;\n        }\n\n        // Compute only the needed CIDs\n        const cids = await this.fileIDComputer.computeCIDs(filePath, neededHashes);\n\n        // Map the computed CIDs back to their respective metadata properties\n        cids.forEach((cid, index) => {\n            const hashType = neededHashes[index];\n            metadata[hashType] = cid;\n        });\n    }\n}\n","import {createReadStream, promises as fs} from 'fs';\nimport {parse} from 'csv-parse';\nimport {parse as parseSync} from 'csv-parse/sync';\nimport {stringify} from 'csv-stringify/sync';\nimport {existsAsync} from \"./ExistsAsync\";\nimport path from \"path\";\nimport {clearInterval} from \"node:timers\";\nimport {CID_ALGORITHM_NAMES} from \"./MultiHashData\";\n\ninterface IndexLine extends Partial<Record<CID_ALGORITHM_NAMES, string>> {\n    path: string;\n    size: string;\n    mtime: string;\n}\n\nexport const INDEX_HEADERS = ['path', 'size', 'mtime'];\n\nexport class HashIndexManager {\n    private cache: Map<string, IndexLine> = new Map<string, IndexLine>();\n    private intervalId: NodeJS.Timeout;\n    private intervalTime: number = 30000;\n    private lastIndexFileSize: number = 0; //size of the index file last time it was read\n    private lastCacheFile: IndexLine[]; //state of the file last time it was read\n    private indexOpsInProgress: boolean = false;\n    private hasChanged: boolean = false;\n    private initialLoad: Promise<void>;\n    private filePaths: { [key in CID_ALGORITHM_NAMES]?: string } = {};\n\n    constructor(filePath: string, private targetHash: CID_ALGORITHM_NAMES[] = [CID_ALGORITHM_NAMES.sha1, CID_ALGORITHM_NAMES.sha256]) {\n        filePath = filePath.replace(\".csv\", \"\");\n        for (const hash of this.targetHash) {\n            this.filePaths[hash] = `${filePath}-${hash}.csv`;\n            if (!this.filePaths[hash]) {\n                throw new Error(`Invalid index file path for ${hash}`);\n            }\n        }\n    }\n\n    public getCache(): Map<string, IndexLine> {\n        return new Map(this.cache);\n    }\n\n    /**\n     * After init consseutively calls to this method will not reload the index\n     * @param autosave\n     */\n    public async init(autosave = true) {\n        if (!this.initialLoad) {\n            this.initialLoad = new Promise<void>(async (resolve, reject) => {\n                try {\n                    for (const hash of this.targetHash) {\n                        if (!this.checkCSVHeaders(this.filePaths[hash], hash)) {\n                            throw new Error(`Invalid index file headers for ${hash}`);\n                        }\n                        await this.loadIndex(hash);\n                    }\n                    if (autosave) {\n                        this.start();\n                    }\n                    resolve();\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        }\n        return this.initialLoad;\n    }\n\n    // Function to check CSV headers\n    private checkCSVHeaders(csvContent: string, hash: CID_ALGORITHM_NAMES): boolean {\n        const records = parseSync(csvContent, {\n            bom: true,\n            columns: true,\n            skip_empty_lines: true,\n        });\n\n        if (records.length === 0) {\n            //we will write the headers\n            return true;\n        }\n\n        // Extract headers\n        const headers = Object.keys(records[0]);\n\n        // Define required headers\n        //from the IndexLine interface\n        const requiredHeaders = [...INDEX_HEADERS, hash];\n\n        // Check if all required headers are present\n        return requiredHeaders.every(header => headers.includes(header));\n    };\n\n    public start() {\n        this.startAutoSave(this.intervalTime);\n    }\n\n    public stopAutoSave() {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n        }\n    }\n\n    private startAutoSave(time: number) {\n        this.stopAutoSave();\n        this.intervalTime = time;\n        this.intervalId = setInterval(() => this.saveCacheToFile(), time);\n    }\n\n    public async loadIndex(hash: CID_ALGORITHM_NAMES): Promise<IndexLine[]> {\n        if (await existsAsync(this.filePaths[hash])) {\n            // check the file size and if it did not change, do not read the file\n            const stats = await fs.stat(this.filePaths[hash]);\n            if (this.lastIndexFileSize !== stats.size) {\n                // Read existing file content and parse it\n                const records: IndexLine[] = await this.readCsv(hash);\n                for (const record of records) {\n                    let indexLine = this.cache.get(record.path);\n                    if (!indexLine) {\n                        this.cache.set(record.path, record);\n                    } else {\n                        //update the cache with the latest data\n                        indexLine[hash] = record[hash];\n                    }\n                }\n                this.lastIndexFileSize = stats.size;\n                this.lastCacheFile = records;\n                return records;\n            } else {\n                return this.lastCacheFile;\n            }\n        }\n        return [];\n    }\n\n    private loadIndexFromCache(): IndexLine[] {\n        return Array.from(this.cache.values());\n    }\n\n    private async readCsv(hash: CID_ALGORITHM_NAMES): Promise<IndexLine[]> {\n        if (!(await existsAsync(this.filePaths[hash]))) {\n            return [];\n        }\n        const start = performance.now();\n\n        const parser = parse({\n            columns: true,\n            skip_empty_lines: true,\n        });\n\n        const records: IndexLine[] = [];\n\n        return new Promise((resolve, reject) => {\n            createReadStream(this.filePaths[hash])\n                .pipe(parser)\n                .on('data', (record) => {\n                    records.push(record);\n                }).on('end', () => {\n                resolve(records);\n                console.log(`Index read ${hash} time ${performance.now() - start}ms`);\n            }).on('error', (err) => {\n                reject(err);\n            });\n        });\n    }\n\n    private async saveCacheToFile(): Promise<void> {\n        if (this.indexOpsInProgress || !this.hasChanged) {\n            return;\n        }\n        this.hasChanged = false;\n        this.indexOpsInProgress = true;\n        const start = performance.now();\n\n        for (const hash of this.targetHash) {\n            let existingRows: IndexLine[] = await this.loadIndex(hash);\n            if (this.cache.size !== 0) {\n                const cacheRows: IndexLine[] = this.loadIndexFromCache();\n                // Filter out cacheRows that are already in the file\n                const newRows = cacheRows.filter(row => !existingRows.find(existingRow => existingRow.path === row.path));\n\n                if (newRows.length !== 0) {\n                    // Serialize new cacheRows to CSV string\n                    const csvString = stringify(newRows, {\n                        header: existingRows.length === 0, // Only add header if the file was empty\n                        columns: [\n                            {key: 'path', header: 'path'},\n                            {key: 'size', header: 'size'},\n                            {key: 'mtime', header: 'mtime'},\n                            {key: hash, header: hash},\n                        ],\n                    });\n\n                    // Append new cacheRows to the file\n                    await fs.appendFile(this.filePaths[hash], csvString);\n                }\n            }\n        }\n        const totalTime = performance.now() - start;\n        console.log(`Index saved in ${totalTime}ms`);\n        // Check if the time to save the index is greater than the interval time. increase the interval time if needed\n        if (totalTime * 10 > this.intervalTime) {\n            this.startAutoSave(totalTime * 10);\n            console.log(`Index save interval increased to ${totalTime * 10}ms`);\n        }\n        this.indexOpsInProgress = false;\n    }\n\n    public getCidForFile(filePath: string, fileSize: number, mtime: string): IndexLine {\n        const fileName = path.basename(filePath);\n        let fileNameIndex = this.cache.get(fileName);\n        if (fileNameIndex) {\n            if (fileNameIndex.mtime) {\n                //if we have a mtime, we need to check it\n                if (fileNameIndex.size === (fileSize + \"\") && fileNameIndex.mtime === mtime) {\n                    return fileNameIndex;\n                }\n            } else {\n                //mtime is optional\n                if (fileNameIndex.size === (fileSize + \"\")) {\n                    return fileNameIndex;\n                }\n            }\n        }\n\n        // 3 - if not found, delete the entry (keeps the index clean)\n        /*if (fileNameIndex && fileNameIndex.size !== (fileSize + \"\") && pathIndex && pathIndex.size !== (fileSize + \"\")) {\n            this.cache.delete(fileName);\n            this.cache.delete(filePath);\n        }*/\n\n        return null;\n    }\n\n    public addFileCid(filePath: string, fileSize: number, mtime: string, hashs: Partial<Record<CID_ALGORITHM_NAMES, string>>): void {\n        if (!filePath || !fileSize || !mtime || !hashs) {\n            throw new Error('Invalid parameters');\n        }\n        for (const hash of this.targetHash) {\n            if (!hashs[hash]) {\n                throw new Error(`Missing hash ${hash}`);\n            }\n        }\n        const size = fileSize + \"\";\n        const baseName = path.basename(filePath);\n        let indexLine = this.cache.get(baseName);\n        if (!indexLine) {\n            const data = {path: baseName, size: size, mtime: mtime, ...hashs};\n            this.cache.set(baseName, data);\n        } else {\n            //update the cache with the latest data\n            for (const hash of this.targetHash) {\n                indexLine[hash] = hashs[hash];\n            }\n        }\n        this.hasChanged = true;\n    }\n\n}","// Example of checking if a file exists asynchronously\n// Note: `existsSync` does not have a direct async equivalent, so we use `access` instead.\nimport {access,constants} from \"fs/promises\";\n\nexport async function existsAsync(filePath: string): Promise<boolean> {\n    try {\n        await access(filePath, constants.F_OK);\n        return true; // File exists\n    } catch {\n        return false; // File does not exist\n    }\n}","import {HashComputer} from \"./HashComputer\";\nimport {CID_ALGORITHM_NAMES, ComputeInterface, MultiHashData} from \"./MultiHashData\";\nimport {HashIndexManager} from \"./HashIndexManager\";\nimport {stat} from \"fs/promises\";\nimport path from \"path\";\n\nexport class ComputeHashIndexCache implements ComputeInterface {\n    hashIndexManager: HashIndexManager;\n    hashComputer: HashComputer;\n\n    constructor(indexFilePath: string,private targetHash: CID_ALGORITHM_NAMES[] = [CID_ALGORITHM_NAMES.sha1, CID_ALGORITHM_NAMES.sha256],workerPath?:string) {\n        this.hashComputer = new HashComputer(targetHash,workerPath);\n        this.hashIndexManager = new HashIndexManager(indexFilePath,targetHash);\n    }\n\n    async computeMissingHash(filePath: string, metadata: MultiHashData): Promise<void> {\n        await this.hashIndexManager.init();\n        let stats = await stat(filePath);\n        if (this.hashIndexManager.getCache().has(path.basename(filePath))) {\n            const indexLine = this.hashIndexManager.getCidForFile(filePath, stats.size, stats.mtime.toISOString());\n            if(indexLine) {\n                for (const hash of this.targetHash) {\n                    if (!metadata[hash] && indexLine[hash]) {\n                        metadata[hash] = indexLine[hash];\n                    }\n                }\n            }\n        }\n        await this.hashComputer.computeMissingHash(filePath, metadata);\n        this.hashIndexManager.addFileCid(filePath, stats.size, stats.mtime.toISOString(), metadata);\n    }\n}","import * as path from 'path';\nimport chokidar from 'chokidar';\nimport {readdir} from \"fs/promises\";\nimport PQueue from \"p-queue\";\nimport {FileProcessorInterface} from \"./FileProcessorInterface.js\";\n\nexport class FolderWatcher {\n    initialized = false;\n    queue = new PQueue({concurrency: 100, autoStart: true});\n    fileProcessor: FileProcessorInterface;\n    queueSize = -1;\n    current = 0;\n    processing = new Set<string>();\n\n    constructor(fileProcessor:FileProcessorInterface,private WATCH_FOLDER_LIST: string, private config:{\n        interval?: number,\n        stabilityThreshold?: number,\n        pollInterval?: number,\n    }) {\n        this.fileProcessor = fileProcessor;\n    }\n\n    /**\n     * Process the directory and its subdirectories\n     * @param directory\n     * @param promises\n     * @private\n     */\n    private async processDirectory(directory: string, promises: Promise<any>[]) {\n        const entries = await readdir(directory, {withFileTypes: true});\n        for (const entry of entries) {\n            const fullPath = path.join(directory, entry.name);\n            if (entry.isDirectory()) {\n                await this.processDirectory(fullPath, promises);\n            } else {\n                const promise = this.processFile(fullPath);\n                promises.push(promise);\n            }\n        }\n    }\n\n    private async countFile(directory: string): Promise<number> {\n        const entries = await readdir(directory, {withFileTypes: true});\n        const countPromises: Promise<any>[] = [];\n\n        for (const entry of entries) {\n            const fullPath = path.join(directory, entry.name);\n            if (entry.isDirectory()) {\n                // Push the promise without waiting for it here\n                countPromises.push(this.countFile(fullPath));\n            } else {\n                // Use an IIFE (Immediately Invoked Function Expression) to handle asynchronous condition\n                countPromises.push(this.queue.add(\n                    async () => (await this.fileProcessor.canProcessFile(fullPath)) ? 1 : 0\n                ));\n            }\n        }\n\n        // Wait for all promises to resolve and then sum up their results\n        const counts = await Promise.all(countPromises);\n        return counts.reduce((acc, current) => acc + current, 0);\n    }\n\n    private async processFile(filePath: string):Promise<void> {\n        if(await this.fileProcessor.canProcessFile(filePath)) {\n            if(!this.processing.has(filePath)) {\n                this.processing.add(filePath);//avoid double processing in the queue\n                const current = ++this.current;\n                await this.queue.add(() => this.fileProcessor.processFile(current, this.queueSize, filePath));\n                this.processing.delete(filePath);\n            }\n        }\n    }\n\n    /**\n     * Process the file and its sibling file included other folder it is a recursive function\n     * @param filePath\n     * @private\n     */\n    private async processFileExtended(filePath: string):Promise<void> {\n        let dirname = path.dirname(filePath);\n        await this.processDirectory(dirname, []);\n    }\n\n    private chokidarWatch(folderList: string[]){\n        const chokidarconfig = {\n            ignoreInitial: true,//ignore the initial scan we have our own function\n            persistent: true,\n            depth: Infinity,\n            awaitWriteFinish: {\n                stabilityThreshold: this.config.stabilityThreshold || 30000,\n                pollInterval: this.config.pollInterval || 5000\n            }\n        };\n\n        let watcher: chokidar.FSWatcher;\n        if ((this.config.interval || 0) <= 0) {\n            watcher = chokidar.watch(folderList, chokidarconfig);\n        } else {\n            watcher = chokidar.watch(folderList, {\n                ...chokidarconfig,\n                usePolling: true,\n                interval: this.config.interval || 0\n            });\n        }\n\n        watcher\n            .on('add', async (filePath) => {\n                try {\n                    await this.processFileExtended(filePath);\n                } catch (error) {\n                    console.error(`Error processing file ${filePath}:`, error);\n                }\n            })\n            .on('change', async (filePath) => {\n                try {\n                    await this.processFileExtended(filePath);\n                } catch (e) {\n                    console.error(`Error processing file ${filePath}:`, e);\n                }\n            })\n            .on('unlink', async (filePath) => {\n                try {\n                    await this.fileProcessor.deleteFile(filePath);\n                    await this.processFileExtended(filePath);\n                } catch (e) {\n                    console.error(`Error processing file deletion:`, e);\n                }\n            })\n            .on('error', (error) => console.error(`Watcher error: ${error}`))\n            .on('ready', () => {\n                console.log(`Watching for file changes on ${folderList}`);\n            });\n    }\n\n    async watch() {\n        let folders = this.WATCH_FOLDER_LIST;\n        if (!folders) {\n            throw new Error(`No folder to watch`);\n        }\n        let folderList = folders.split(',');\n\n        this.chokidarWatch(folderList);\n\n        //start the initial scan\n        let countPromises = [];\n        for (let i = 0; i < folderList.length; i++) {\n            folderList[i] = path.normalize(folderList[i]);\n            countPromises.push(this.countFile(folderList[i]));\n        }\n        const count = (await Promise.all(countPromises)).reduce((acc, current) => acc + current, 0);\n        console.log(`Found ${count} files to process`);\n        this.queueSize = count;\n        let promises: Promise<any>[] = [];\n        for (let i = 0; i < folderList.length; i++) {\n            folderList[i] = path.normalize(folderList[i]);\n            await this.processDirectory(folderList[i], promises);\n        }\n        await Promise.all(promises);\n        this.initialized = true;\n\n        console.log(`Watcher ready`);\n    }\n}\n"]}