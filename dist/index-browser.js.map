{"version":3,"sources":["../src/lib/hash-compute/HashComputer.ts"],"names":["HashComputer","targetHash","stream","metadata","neededHashes","hashName","cids","computeCIDs","index","cid","hashType"],"mappings":"0HAKO,IAAMA,EAAN,KAAkB,CAErB,YAAoBC,EAAmC,CAAnC,gBAAAA,CACpB,CAEA,MAAM,mBAAmBC,EAAkBC,EAAwC,CAE/E,IAAMC,EAAe,KAAK,WAAW,OAAOC,GAAY,CAACF,EAASE,CAAQ,CAAC,EAG3E,GAAID,EAAa,SAAW,EACxB,OAIJ,IAAME,EAAO,MAAMC,EAAY,CAAC,OAAAL,EAAQ,WAAWE,CAAY,CAAC,EAGhE,OAAW,CAACI,EAAOC,CAAG,IAAKH,EAAK,QAAQ,EAAG,CACvC,IAAMI,EAAWN,EAAaI,CAAK,EACnCL,EAASO,CAAQ,EAAID,CACzB,CACJ,CACJ","sourcesContent":["import {CID_ALGORITHM_NAMES, MultiHashData} from \"./MultiHashData\";\nimport {Readable} from \"stream\";\n\nimport {computeCIDs} from \"@root/file-id/ComputeHash\";\n\nexport class HashComputer{\n\n    constructor(private targetHash: CID_ALGORITHM_NAMES[]) {\n    }\n\n    async computeMissingHash(stream: Readable, metadata: MultiHashData): Promise<void> {\n        // Dynamically determine which hashes are needed\n        const neededHashes = this.targetHash.filter(hashName => !metadata[hashName]);\n\n        // If all hashes are already computed, skip the processing\n        if (neededHashes.length === 0) {\n            return;\n        }\n\n        // Compute only the needed CIDs\n        const cids = await computeCIDs({stream, algorithms:neededHashes});\n\n        // Map the computed CIDs back to their respective metadata properties\n        for (const [index, cid] of cids.entries()) {\n            const hashType = neededHashes[index];\n            metadata[hashType] = cid;\n        }\n    }\n}\n"]}