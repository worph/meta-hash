{"version":3,"sources":["../src/lib/hash-compute/HashComputer.ts"],"names":[],"mappings":";;;;;;;;;;;AAKO,IAAM,eAAN,MAAkB;AAAA,EAErB,YAAoB,YAAmC;AAAnC;AAAA,EACpB;AAAA,EAEA,MAAM,mBAAmB,QAAkB,UAAwC;AAE/E,UAAM,eAAe,KAAK,WAAW,OAAO,cAAY,CAAC,SAAS,QAAQ,CAAC;AAG3E,QAAI,aAAa,WAAW,GAAG;AAC3B;AAAA,IACJ;AAGA,UAAM,OAAO,MAAM,YAAY,EAAC,QAAQ,YAAW,aAAY,CAAC;AAGhE,eAAW,CAAC,OAAO,GAAG,KAAK,KAAK,QAAQ,GAAG;AACvC,YAAM,WAAW,aAAa,KAAK;AACnC,eAAS,QAAQ,IAAI;AAAA,IACzB;AAAA,EACJ;AACJ","sourcesContent":["import {CID_ALGORITHM_NAMES, MultiHashData} from \"./MultiHashData\";\nimport {Readable} from \"stream\";\n\nimport {computeCIDs} from \"@root/file-id/ComputeHash\";\n\nexport class HashComputer{\n\n    constructor(private targetHash: CID_ALGORITHM_NAMES[]) {\n    }\n\n    async computeMissingHash(stream: Readable, metadata: MultiHashData): Promise<void> {\n        // Dynamically determine which hashes are needed\n        const neededHashes = this.targetHash.filter(hashName => !metadata[hashName]);\n\n        // If all hashes are already computed, skip the processing\n        if (neededHashes.length === 0) {\n            return;\n        }\n\n        // Compute only the needed CIDs\n        const cids = await computeCIDs({stream, algorithms:neededHashes});\n\n        // Map the computed CIDs back to their respective metadata properties\n        for (const [index, cid] of cids.entries()) {\n            const hashType = neededHashes[index];\n            metadata[hashType] = cid;\n        }\n    }\n}\n"]}