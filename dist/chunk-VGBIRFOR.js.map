{"version":3,"sources":["../src/lib/fileID/ShaComputeWorker.ts","../src/lib/MultiHashData.ts"],"names":["createReadStream","createHash","CID","create","CID_ALGORITHM_CODES","CID_ALGORITHM_NAMES","CID_ALGORITHM","computeCIDs","filePath","algorithms","hashFunctions","hashers","algo","stream","chunk","item","code","hasher","hashBuffer","digest"],"mappings":"AAAA,OAAS,oBAAAA,MAAwB,KACjC,OAAoB,cAAAC,MAAiB,SACrC,OAAS,OAAAC,MAAW,mBACpB,OAAS,UAAAC,MAAc,6BCShB,IAAKC,OACRA,IAAA,OAAS,IAAT,SACAA,IAAA,KAAO,IAAP,OACAA,IAAA,IAAM,KAAN,MACAA,IAAA,SAAW,IAAX,WAJQA,OAAA,IAQAC,OACRA,EAAA,OAAS,eACTA,EAAA,KAAO,WACPA,EAAA,IAAM,UACNA,EAAA,SAAW,eAJHA,OAAA,IAQAC,OACRA,EAAA,OAAS,WACTA,EAAA,KAAO,OACPA,EAAA,IAAM,MACNA,EAAA,SAAW,WAJHA,OAAA,IDVZ,eAAOC,EAAmC,CAAE,SAAAC,EAAU,WAAAC,CAAW,EAA+E,CAC5I,IAAMC,EACA,CACD,eAA6B,CAAE,QAAkC,OAAQT,EAAW,QAAQ,CAAE,EAC9F,SAA2B,CAAE,QAAgC,OAAQA,EAAW,MAAM,CAAE,EACxF,QAA0B,CAAE,SAA+B,OAAQA,EAAW,KAAK,CAAE,EACrF,eAA+B,CAAE,QAAoC,OAAOA,EAAW,UAAU,CAAE,CACxG,EAEMU,EAAUF,EAAW,IAAIG,IAAS,CACpC,OAAQF,EAAcE,CAAI,EAAE,OAC5B,KAAMF,EAAcE,CAAI,EAAE,IAC9B,EAAE,EAEIC,EAASb,EAAiBQ,CAAQ,EACxC,cAAiBM,KAASD,EACtB,QAAWE,KAAQJ,EACfI,EAAK,OAAO,OAAOD,CAAK,EAUhC,OANa,MAAM,QAAQ,IAAIH,EAAQ,IAAI,MAAO,CAAE,KAAAK,EAAM,OAAAC,CAAO,IAAM,CACnE,IAAMC,EAAaD,EAAO,OAAO,EAC3BE,EAAShB,EAAOa,EAAME,CAAU,EACtC,OAAOhB,EAAI,SAASc,EAAMG,CAAM,EAAE,SAAS,CAC/C,CAAC,CAAC,CAGN","sourcesContent":["import { createReadStream } from \"fs\";\nimport {BinaryLike, createHash} from 'crypto';\nimport { CID } from 'multiformats/cid';\nimport { create } from \"multiformats/hashes/digest\";\nimport {CID_ALGORITHM, CID_ALGORITHM_CODES, CID_ALGORITHM_NAMES} from \"../MultiHashData\";\n\nexport interface SimpleHash {\n    update(data: BinaryLike),\n    digest(): Buffer;\n}\n\n\n/**\n * Compute the CIDs of a file using specific algorithms\n * @param filePath The path to the file\n * @param algorithms Array of algorithms ('sha256', 'sha1')\n * @returns Array of CIDs (in the order of the algorithms)\n */\nexport default async function computeCIDs({ filePath, algorithms }: { filePath: string; algorithms: CID_ALGORITHM_NAMES[] }): Promise<string[]> {\n    const hashFunctions: Record<string, { code: number, hasher: SimpleHash }>\n        = {\n        [CID_ALGORITHM_NAMES.sha256]: { code: CID_ALGORITHM_CODES.sha256, hasher: createHash('sha256') },\n        [CID_ALGORITHM_NAMES.sha1]: { code: CID_ALGORITHM_CODES.sha1, hasher: createHash('sha1') },\n        [CID_ALGORITHM_NAMES.md5]: { code: CID_ALGORITHM_CODES.md5, hasher: createHash('md5') },\n        [CID_ALGORITHM_NAMES.sha3_256]: { code: CID_ALGORITHM_CODES.sha3_256, hasher:createHash('sha3-256') }\n    };\n\n    const hashers = algorithms.map(algo => ({\n        hasher: hashFunctions[algo].hasher,\n        code: hashFunctions[algo].code\n    }));\n\n    const stream = createReadStream(filePath);\n    for await (const chunk of stream) {\n        for (const item of hashers) {\n            item.hasher.update(chunk);\n        }\n    }\n\n    const cids = await Promise.all(hashers.map(async ({ code, hasher }) => {\n        const hashBuffer = hasher.digest();\n        const digest = create(code, hashBuffer);\n        return CID.createV1(code, digest).toString();\n    }));\n\n    return cids;\n}\n","export interface MultiHashData {\n    \"cid_sha2-256\"?: string;//0x12 sha2-256\n    cid_sha1?: string; // 0x11 sha1\n    cid_md5?: string; // 0xd5 md5\n    \"cid_sha3-256\"?: string; // 0x16 sha3-256\n    //cid_crc32?: string; //0x0132 CRC32 (SFV) TODO\n}\n\nexport interface ComputeInterface {\n    computeMissingHash(filePath: string, metadata: MultiHashData): Promise<void>;\n}\n\nexport enum CID_ALGORITHM_CODES {\n    sha256 = 0x12,\n    sha1 = 0x11,\n    md5 = 0xd5,\n    sha3_256 = 0x16,\n    //crc32 = 0x0132\n}\n\nexport enum CID_ALGORITHM_NAMES {\n    sha256 = 'cid_sha2-256',\n    sha1 = 'cid_sha1',\n    md5 = 'cid_md5',\n    sha3_256 = 'cid_sha3-256',\n    //crc32 = 'cid_crc32'\n}\n\nexport enum CID_ALGORITHM {\n    sha256 = 'sha2-256',\n    sha1 = 'sha1',\n    md5 = 'md5',\n    sha3_256 = 'sha3-256',\n    //crc32 = 'crc32'\n}"]}